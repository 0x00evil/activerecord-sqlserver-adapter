
= SQL Server Testing Setup

  1) Clone adapter http://github.com/rails-sqlserver/2000-2005-adapter
  2) Switch to remote tracking branch "3.0.0.beta1" or the latest beta version.
  3) Set the ARSQLSERVER_SOURCE environment variable with the path of this repo.

= Arel Testing Setup

  1) Clone our fork of Arel. http://github.com/rails-sqlserver/arel
  2) Switch to remote tracking branch "sqlserver"
  3) Set the AREL_SOURCE environment variable with path of this repo.

= Rails

  1) Clone rails.
  2) Creat a local topic branch, maybe something like sqlserver_3.0.0.beta
  3) Apply the following diff, till we push this upstream. http://gist.github.com/443568
  4) Set the RAILS_SOURCE environment variable with the path of this repo.

= Testing Last Steps And Notes

So bundler manages the dependencies now and if you have set the correct environment 
variables then all dependency paths for development should be resolved. It is now best to 
run "bundle install" first from your Arel, then to the adapter repo. Now you should be able
to run "bundle exec rake spec:sqlserver" in Arel to run tests. Since we put bundler as
a development dependency in the adapter, all you need to do is run "rake test".

Remember you have to set an environment variable for the DSN of the adapter, see the ODBC
connection information for details. Lastly, it is typically good practice to do your work 
on a local branch of our remote tracking branch.



= SQL Server Todo
  
  2384 tests, 9524 assertions, 30 failures, 37 errors
  
  * SQL Server Test Cases
    x adapter_test_sqlserver.rb               (8) Limit offset stuff.
    x eager_association_test_sqlserver.rb     (2) Limit offset stuff.
    x inheritance_test_sqlserver.rb           (1) Recheck orig.
    x method_scoping_test_sqlserver.rb        (1) Recheck orig.
    √ named_scope_test_sqlserver.rb           (0) Recheck orig.
    x offset_and_limit_test_sqlserver.rb      (3) Offset/Limit stuff.
    x pessimistic_locking_test_sqlserver.rb   (7) Tons of lock problems.
    x table_name_test_sqlserver.rb            (1) Query pattern.
  
  * Verify coerced tests
    Undefined coerced test: AdapterTest#test_add_limit_offset_should_sanitize_sql_injection_for_limit_without_comas
    Undefined coerced test: AdapterTest#test_add_limit_offset_should_sanitize_sql_injection_for_limit_with_comas
    Undefined coerced test: EagerAssociationTest#test_eager_with_has_many_and_limit_and_high_offset_and_multiple_array_conditions
    Undefined coerced test: EagerAssociationTest#test_eager_with_has_many_and_limit_and_high_offset_and_multiple_hash_conditions
    Undefined coerced test: EagerAssociationTest#test_count_with_include
    Undefined coerced test: AttributeMethodsTest#test_typecast_attribute_from_select_to_false
    Undefined coerced test: AttributeMethodsTest#test_typecast_attribute_from_select_to_true
    Undefined coerced test: BasicsTest#test_read_attributes_before_type_cast_on_datetime
    Undefined coerced test: CalculationsTest#test_should_sum_expression
    Undefined coerced test: InheritanceTest#test_a_bad_type_column
    Undefined coerced test: InheritanceTest#test_eager_load_belongs_to_primary_key_quoting
    Undefined coerced test: NestedScopingTest#test_merged_scoped_find
    Undefined coerced test: MigrationTest#test_add_column_not_null_without_default
    Undefined coerced test: ChangeTableMigrationsTest#test_string_creates_string_column
    Undefined coerced test: NamedScopeTest#test_named_scopes_honor_current_scopes_from_when_defined
    Undefined coerced test: QueryCacheTest#test_cache_does_not_wrap_string_results_in_arrays
  * Move all sqlserver_adapter/core_ext files to sqlserver/core_ext.
  * Make sure the repair special columns was good to go.
  * Possibly remove 2000 support and query methods.
  * Make sure Gemspec is good.
  
    

= Arel Todo

  338 examples, 4 failures, 3 pending
  
  * integration/joins/
    √ with_adjacency_spec.rb
    x with_aggregations_spec.rb   # => 1 failure (debug after take spec)
    √ with_compounds_spec.rb
  * unit/predicates
    √ binary_spec.rb
    √ equality_spec.rb
    √ in_spec.rb
    √ noteq_spec.rb
    √ predicates_spec.rb
  * unit/primitives
    √ attribute_spec.rb
    √ expression_spec.rb
    √ literal_spec.rb
    √ value_spec.rb
  * unit/relations
    √ alias_spec.rb
    x delete_spec.rb      # => 1 failure (debug after take spec)
    √ from_spec.rb
    √ group_spec.rb
    √ having_spec.rb
    √ insert_spec.rb
    √ join_spec.rb
    x lock_spec.rb        # => 1 failure (todo on purpose)
      - Add more tests.
    √ order_spec.rb
    √ project_spec.rb
    • skip_spec.rb
    √ table_spec.rb
    • take_spec.rb
    x update_spec.rb      # => 1 failure (debug after take spec)
    √ where_spec.rb
  

  * Review/remove our long winded add_limit_offset!

    def add_lock!(sql, options)
      # http://blog.sqlauthority.com/2007/04/27/sql-server-2005-locking-hints-and-examples/
      return unless options[:lock]
      lock_type = options[:lock] == true ? 'WITH(HOLDLOCK, ROWLOCK)' : options[:lock]
      sql.gsub! %r|LEFT OUTER JOIN\s+(.*?)\s+ON|im, "LEFT OUTER JOIN \\1 #{lock_type} ON"
      sql.gsub! %r{FROM\s([\w\[\]\.]+)}im, "FROM \\1 #{lock_type}"
    end
    
    def add_limit_offset_for_association_limiting!(sql, options)
      sql.replace %|
        SET NOCOUNT ON
        DECLARE @row_number TABLE (row int identity(1,1), id int)
        INSERT INTO @row_number (id)
          #{sql}
        SET NOCOUNT OFF
        SELECT id FROM (
          SELECT TOP #{options[:limit]} * FROM (
            SELECT TOP #{options[:limit] + options[:offset]} * FROM @row_number ORDER BY row
          ) AS tmp1 ORDER BY row DESC
        ) AS tmp2 ORDER BY row
      |.gsub(/[ \t\r\n]+/,' ')
    end
    
    def sql_for_association_limiting?(sql)
      if md = sql.match(/^\s*SELECT(.*)FROM.*GROUP BY.*ORDER BY.*/im)
        select_froms = md[1].split(',')
        select_froms.size == 1 && !select_froms.first.include?('*')
      end
    end

    def change_order_direction(order)
      order.split(",").collect {|fragment|
        case fragment
          when  /\bDESC\b/i     then fragment.gsub(/\bDESC\b/i, "ASC")
          when  /\bASC\b/i      then fragment.gsub(/\bASC\b/i, "DESC")
          else                  String.new(fragment).split(',').join(' DESC,') + ' DESC'
        end
      }.join(",")
    end
  
  
  * Find out if this is needed anywhere.
    
    def add_order_by_for_association_limiting!(sql, options)
      # Disertation http://gist.github.com/24073
      # Information http://weblogs.sqlteam.com/jeffs/archive/2007/12/13/select-distinct-order-by-error.aspx
      return sql if options[:order].blank?
      columns = sql.match(/SELECT\s+DISTINCT(.*?)FROM/)[1].strip
      sql.sub!(/SELECT\s+DISTINCT/,'SELECT')
      sql << "GROUP BY #{columns} ORDER BY #{order_to_min_set(options[:order])}"
    end
    
    def orders_and_dirs_set(order)
      orders = order.sub('ORDER BY','').split(',').map(&:strip).reject(&:blank?)
      orders_dirs = orders.map do |ord|
        dir = nil
        ord.sub!(/\b(asc|desc)$/i) do |match|
          if match
            dir = match.upcase.strip
            ''
          end
        end
        [ord.strip, dir]
      end
    end
    
    def order_to_min_set(order)
      orders_dirs = orders_and_dirs_set(order)
      orders_dirs.map do |o,d|
        "MIN(#{o}) #{d}".strip
      end.join(', ')
    end



