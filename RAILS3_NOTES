
= SQL Server Testing Setup

  1) Clone adapter http://github.com/rails-sqlserver/2000-2005-adapter
  2) Switch to remote tracking branch "3.0.0.beta1" or the latest beta version.
  3) Set the ARSQLSERVER_SOURCE environment variable with the path of this repo.

= Arel Testing Setup

  1) Clone our fork of Arel. http://github.com/rails-sqlserver/arel
  2) Switch to remote tracking branch "sqlserver"
  3) Set the AREL_SOURCE environment variable with path of this repo.

= Rails

  1) Clone rails.
  2) Creat a local topic branch, maybe something like sqlserver_3.0.0.beta
  3) Apply the following diff, till we push this upstream. http://gist.github.com/443568
  4) Set the RAILS_SOURCE environment variable with the path of this repo.

= Testing Last Steps And Notes

So bundler manages the dependencies now and if you have set the correct environment 
variables then all dependency paths for development should be resolved. It is now best to 
run "bundle install" first from your Arel, then to the adapter repo. Now you should be able
to run "bundle exec rake spec:sqlserver" in Arel to run tests. Since we put bundler as
a development dependency in the adapter, all you need to do is run "rake test".

Remember you have to set an environment variable for the DSN of the adapter, see the ODBC
connection information for details. Lastly, it is typically good practice to do your work 
on a local branch of our remote tracking branch.



= SQL Server Todo
  
  2364 tests, 9484 assertions, 7 failures, 44 errors
  
  * SQL Server Test Cases
    x inheritance_test_sqlserver.rb           (1) Recheck orig.
    x method_scoping_test_sqlserver.rb        (1) Recheck orig.
  
  * Verify coerced tests
    Undefined coerced test: EagerAssociationTest#test_eager_with_has_many_and_limit_and_high_offset_and_multiple_array_conditions
    Undefined coerced test: EagerAssociationTest#test_eager_with_has_many_and_limit_and_high_offset_and_multiple_hash_conditions
    Undefined coerced test: EagerAssociationTest#test_count_with_include
    Undefined coerced test: AttributeMethodsTest#test_typecast_attribute_from_select_to_false
    Undefined coerced test: AttributeMethodsTest#test_typecast_attribute_from_select_to_true
    Undefined coerced test: BasicsTest#test_read_attributes_before_type_cast_on_datetime
    Undefined coerced test: CalculationsTest#test_should_sum_expression
    Undefined coerced test: InheritanceTest#test_a_bad_type_column
    Undefined coerced test: InheritanceTest#test_eager_load_belongs_to_primary_key_quoting
    Undefined coerced test: NestedScopingTest#test_merged_scoped_find
    Undefined coerced test: MigrationTest#test_add_column_not_null_without_default
    Undefined coerced test: ChangeTableMigrationsTest#test_string_creates_string_column
    Undefined coerced test: QueryCacheTest#test_cache_does_not_wrap_string_results_in_arrays
  * Make sure the repair special columns was good to go.
  * Possibly remove 2000 support and query methods.
  * Make sure Gemspec is good.



= Arel Todo

  338 examples, 0 failures, 3 pending
  
  * unit/relations
    • skip_spec.rb  (try adding more, maybe with order)
    • take_spec.rb  (try adding more, maybe with order)


  * Review/remove our long winded add_limit_offset!

    def add_lock!(sql, options)
      # http://blog.sqlauthority.com/2007/04/27/sql-server-2005-locking-hints-and-examples/
      return unless options[:lock]
      lock_type = options[:lock] == true ? 'WITH(HOLDLOCK, ROWLOCK)' : options[:lock]
      sql.gsub! %r|LEFT OUTER JOIN\s+(.*?)\s+ON|im, "LEFT OUTER JOIN \\1 #{lock_type} ON"
      sql.gsub! %r{FROM\s([\w\[\]\.]+)}im, "FROM \\1 #{lock_type}"
    end
    
    def add_limit_offset_for_association_limiting!(sql, options)
      sql.replace %|
        SET NOCOUNT ON
        DECLARE @row_number TABLE (row int identity(1,1), id int)
        INSERT INTO @row_number (id)
          #{sql}
        SET NOCOUNT OFF
        SELECT id FROM (
          SELECT TOP #{options[:limit]} * FROM (
            SELECT TOP #{options[:limit] + options[:offset]} * FROM @row_number ORDER BY row
          ) AS tmp1 ORDER BY row DESC
        ) AS tmp2 ORDER BY row
      |.gsub(/[ \t\r\n]+/,' ')
    end
    
    context 'for #sql_for_association_limiting?' do
      
      should_eventually 'return false for simple selects with no GROUP BY and ORDER BY' do
        assert !sql_for_association_limiting?("SELECT * FROM [posts]")
      end
      
      should_eventually 'return true to single SELECT, ideally a table/primarykey, that also has a GROUP BY and ORDER BY' do
        assert sql_for_association_limiting?("SELECT [posts].id FROM...GROUP BY [posts].id ORDER BY MIN(posts.id)")
      end
      
      should_eventually 'return false to single * wildcard SELECT that also has a GROUP BY and ORDER BY' do
        assert !sql_for_association_limiting?("SELECT * FROM...GROUP BY [posts].id ORDER BY MIN(posts.id)")
      end
      
      should_eventually 'return false to multiple columns in the select even when GROUP BY and ORDER BY are present' do
        sql = "SELECT [accounts].credit_limit, firm_id FROM...GROUP BY firm_id ORDER BY firm_id"
        assert !sql_for_association_limiting?(sql)
      end
      
    end
    
    def sql_for_association_limiting?(sql)
      if md = sql.match(/^\s*SELECT(.*)FROM.*GROUP BY.*ORDER BY.*/im)
        select_froms = md[1].split(',')
        select_froms.size == 1 && !select_froms.first.include?('*')
      end
    end

    def change_order_direction(order)
      order.split(",").collect {|fragment|
        case fragment
          when  /\bDESC\b/i     then fragment.gsub(/\bDESC\b/i, "ASC")
          when  /\bASC\b/i      then fragment.gsub(/\bASC\b/i, "DESC")
          else                  String.new(fragment).split(',').join(' DESC,') + ' DESC'
        end
      }.join(",")
    end
  
  
  * Find out if this is needed anywhere.
    
    def add_limit_with_sqlserver_order_checking!(sql, options, scope = :auto)
      if connection.respond_to?(:sqlserver?)
        scope = scope(:find) if :auto == scope
        if scope
          options = options.dup
          scoped_order = scope[:order]
          order = options[:order]
          if order && scoped_order
            options[:order] = add_order_with_sqlserver_unique_checking!('', order, scope).gsub(/^ ORDER BY /,'')
          elsif scoped_order
            options[:order] = scoped_order
          end
        end
      end
      add_limit_without_sqlserver_order_checking!(sql, options, scope)
    end
    
    context "for add_limit! within a scoped method call" do
      setup do
        @connection.stubs(:select_value).with(regexp_matches(/TotalRows/)).returns '100000000'
      end

      should 'not add any ordering if the scope doesn\'t have an order' do
        assert_equal 'SELECT * FROM (SELECT TOP 10 * FROM (SELECT TOP 40 * FROM [developers]) AS tmp1) AS tmp2', add_limit!('SELECT * FROM [developers]', {:offset => 30, :limit => 10}, {})
      end

      should 'still add the default ordering if the scope doesn\'t have an order but the raw order option is there' do
        assert_equal 'SELECT * FROM (SELECT TOP 10 * FROM (SELECT TOP 40 * FROM [developers]) AS tmp1 ORDER BY [name] DESC) AS tmp2 ORDER BY [name]', add_limit!('SELECT * FROM [developers]', {:offset => 30, :limit => 10, :order => 'name'}, {})
      end

      should 'add scoped order options to the offset and limit sql' do
        assert_equal 'SELECT * FROM (SELECT TOP 10 * FROM (SELECT TOP 40 * FROM [developers]) AS tmp1 ORDER BY [id] DESC) AS tmp2 ORDER BY [id]', add_limit!('SELECT * FROM [developers]', {:offset => 30, :limit => 10}, {:order => 'id'})
      end

      should 'combine scoped order with raw order options in the offset and limit sql' do
        assert_equal 'SELECT * FROM (SELECT TOP 10 * FROM (SELECT TOP 40 * FROM [developers]) AS tmp1 ORDER BY [name] DESC, [id] DESC) AS tmp2 ORDER BY [name], [id]', add_limit!('SELECT * FROM [developers]', {:offset => 30, :limit => 10, :order => 'name'}, {:order => 'id'})
      end
    end
    
    def add_limit!(sql, options, scope = :auto)
      ActiveRecord::Base.send :add_limit!, sql, options, scope
      sql
    end
    
    
    
    
    
    def add_order_with_sqlserver_unique_checking!(sql, order, scope = :auto)
      if connection.respond_to?(:sqlserver?)
        order_sql = ''
        add_order_without_sqlserver_unique_checking!(order_sql, order, scope)
        unless order_sql.blank?
          unique_order_hash = {}
          select_table_name = connection.send(:get_table_name,sql)
          select_table_name.tr!('[]','') if select_table_name
          orders_and_dirs_set = connection.send(:orders_and_dirs_set,order_sql)
          unique_order_sql = orders_and_dirs_set.inject([]) do |array,order_dir|
            ord, dir = order_dir
            ord_tn_and_cn = ord.to_s.split('.').map{|o|o.tr('[]','')}
            ord_table_name, ord_column_name = if ord_tn_and_cn.size > 1
                                                ord_tn_and_cn
                                              else
                                                [nil, ord_tn_and_cn.first]
                                              end
            unique_key = [(ord_table_name || select_table_name), ord_column_name]
            if unique_order_hash[unique_key]
              array
            else
              unique_order_hash[unique_key] = true
              array << "#{ord} #{dir}".strip
            end
          end.join(', ')
          sql << " ORDER BY #{unique_order_sql}"
        end
      else
        add_order_without_sqlserver_unique_checking!(sql, order, scope)
      end
    end
    
    def order_to_min_set(order)
      orders_dirs = orders_and_dirs_set(order)
      orders_dirs.map do |o,d|
        "MIN(#{o}) #{d}".strip
      end.join(', ')
    end
    
    context 'dealing with various orders SQL snippets' do
      
      setup do
        @single_order = 'comments.id'
        @single_order_with_desc = 'comments.id DESC'
        @two_orders = 'comments.id, comments.post_id'
        @two_orders_with_asc = 'comments.id, comments.post_id ASC'
        @two_orders_with_desc_and_asc = 'comments.id DESC, comments.post_id ASC'
        @two_duplicate_order_with_dif_dir = "id, id DESC"
      end
      
      should 'remove duplicate or maintain the same order by statements giving precedence to first using #add_order! method chain extension' do
        assert_equal ' ORDER BY comments.id', add_order!(@single_order)
        assert_equal ' ORDER BY comments.id DESC', add_order!(@single_order_with_desc)
        assert_equal ' ORDER BY comments.id, comments.post_id', add_order!(@two_orders)
        assert_equal ' ORDER BY comments.id DESC, comments.post_id ASC', add_order!(@two_orders_with_desc_and_asc)
        assert_equal 'SELECT * FROM [developers] ORDER BY id', add_order!('id, developers.id DESC','SELECT * FROM [developers]')
        assert_equal 'SELECT * FROM [developers] ORDER BY [developers].[id] DESC', add_order!('[developers].[id] DESC, id','SELECT * FROM [developers]')
      end
    
      should 'leave order by alone when same column crosses two tables' do
        assert_equal ' ORDER BY developers.name, projects.name', add_order!('developers.name, projects.name')
      end
      
      should 'take all types of order options and convert them to MIN functions using #order_to_min_set' do
        assert_equal 'MIN(comments.id)', order_to_min_set(@single_order)
        assert_equal 'MIN(comments.id), MIN(comments.post_id)', order_to_min_set(@two_orders)
        assert_equal 'MIN(comments.id) DESC', order_to_min_set(@single_order_with_desc)
        assert_equal 'MIN(comments.id), MIN(comments.post_id) ASC', order_to_min_set(@two_orders_with_asc)
        assert_equal 'MIN(comments.id) DESC, MIN(comments.post_id) ASC', order_to_min_set(@two_orders_with_desc_and_asc)
      end
    
    end
    
    def add_order!(order,sql='')
      ActiveRecord::Base.send :add_order!, sql, order, nil
      sql
    end
    
    def order_to_min_set(order)
      @connection.send :order_to_min_set, order
    end
    
    
    
    
    def add_order_by_for_association_limiting!(sql, options)
      # Disertation http://gist.github.com/24073
      # Information http://weblogs.sqlteam.com/jeffs/archive/2007/12/13/select-distinct-order-by-error.aspx
      return sql if options[:order].blank?
      columns = sql.match(/SELECT\s+DISTINCT(.*?)FROM/)[1].strip
      sql.sub!(/SELECT\s+DISTINCT/,'SELECT')
      sql << "GROUP BY #{columns} ORDER BY #{order_to_min_set(options[:order])}"
    end
    
    
    
    
    def orders_and_dirs_set(order)
      orders = order.sub('ORDER BY','').split(',').map(&:strip).reject(&:blank?)
      orders_dirs = orders.map do |ord|
        dir = nil
        ord.sub!(/\b(asc|desc)$/i) do |match|
          if match
            dir = match.upcase.strip
            ''
          end
        end
        [ord.strip, dir]
      end
    end
    
    should 'convert to an 2D array of column/direction arrays using #orders_and_dirs_set' do
      assert_equal [['comments.id',nil]], orders_and_dirs_set('ORDER BY comments.id'), 'Needs to remove ORDER BY'
      assert_equal [['comments.id',nil]], orders_and_dirs_set(@single_order)
      assert_equal [['comments.id',nil],['comments.post_id',nil]], orders_and_dirs_set(@two_orders)
      assert_equal [['comments.id',nil],['comments.post_id','ASC']], orders_and_dirs_set(@two_orders_with_asc)
      assert_equal [['id',nil],['id','DESC']], orders_and_dirs_set(@two_duplicate_order_with_dif_dir)
    end
    
    def orders_and_dirs_set(order)
      @connection.send :orders_and_dirs_set, order
    end
    
    
    




